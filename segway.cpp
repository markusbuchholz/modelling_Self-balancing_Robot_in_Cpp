#include <iostream>
#include <tuple>
#include <vector>
#include <math.h>

#include "matplotlibcpp.h"

namespace plt = matplotlibcpp;

//----------- system dynamic parameters --------------------

float L = 1.0;
float r = 0.5;  
float l = 2.5;  
float m = 500;  
float M = 80;   
float a = 1.0;  
float g = 9.81; 

float dt = 0.001; 

// proportional coefficients
float kp1 = 12000.0; 
float kp2 = 300.0;   

// differential coefficients
float kd1 = 2500.0;     
float kd2 = 10 * 200.0; 

// from Jupyter variables
float A = m * (a * a + (l * l) / 12); 
float B = m * a * r;                  
float C = (m + 3 / 2 * M) * r * r;    

float D = A * C; 
float E = B * B;
float F = m * g * a; 

//-----------------------------------------------------------
// Torque generated by motor installed in wheel
float controlTrq(float theta, float fi, float theta_dot, float fi_dot)
{
    float control = kp1 * theta + kd1 * theta_dot + kp2 * theta_dot + kd2 * fi_dot;
    return control;
}

//-----------------------------------------------------------
// theta_dot - pendulum angular velocity
float function1(float fi)
{

    return fi;
}

//-----------------------------------------------------------
// theta_dot_dot - pendulum angular acceleration
float function2(float theta, float fi, float theta_dot, float fi_dot)
{

    float theta_dot_dot = (C * (F * std::sin(theta) - controlTrq(theta, fi, theta_dot, fi_dot)) - B * std::cos(theta) * (controlTrq(theta, fi, theta_dot, fi_dot) + B * (fi * fi) * std::sin(theta))) / (D - E * (std::cos(theta)) * (std::cos(theta)));

    return theta_dot_dot;
}

//-----------------------------------------------------------
// phi_dot - wheel angular velocity
float function3(float fi_dot)
{

    return fi_dot;
}

//-----------------------------------------------------------
// phi_dot_dot - wheel angular acceleration
float function4(float theta, float fi, float theta_dot, float fi_dot)
{

    float phi_dot_dot = (A * (F * std::sin(theta) - controlTrq(theta, fi, theta_dot, fi_dot)) - B * std::cos(theta) * (controlTrq(theta, fi, theta_dot, fi_dot) + B * (fi * fi) * std::sin(theta))) / (D - E * (std::cos(theta)) * (std::cos(theta)));

    return phi_dot_dot;
}

//-----------------------------------------------------------

std::tuple<std::vector<float>, std::vector<float>, std::vector<float>, std::vector<float>, std::vector<float>, std::vector<float>> methodRuneKuttaSegway()
{

    std::vector<float> diffEq1;
    std::vector<float> diffEq2;
    std::vector<float> diffEq3;
    std::vector<float> diffEq4;
    std::vector<float> torque;
    std::vector<float> time;

    // init values
    float x1 = (M_PI / 180) * 30; // theta - pendulum
    float x2 = 0;                 // theta_dot - pednulum
    float x3 = 0;                 // phi  - wheel
    float x4 = 0;                 // phi_dot -wheel
    float t = 0.0;                //init time

    diffEq1.push_back(x1);
    diffEq2.push_back(x2);
    diffEq3.push_back(x3);
    diffEq4.push_back(x4);
    time.push_back(t);
    torque.push_back(0);

    for (int ii = 0; ii < 10000; ii++)
    {
        t = t + dt;
        float k11 = function1(x2);
        float k12 = function2(x1, x2, x3, x4);
        float k13 = function3(x4);
        float k14 = function4(x1, x2, x3, x4);

        float k21 = function1(x2 + dt / 2 * k12);
        float k22 = function2(x1 + dt / 2 * k11, x2 + dt / 2 * k12, x3 + dt / 2 * k13, x4 + dt / 2 * k14);
        float k23 = function3(x4 + dt / 2 * k14);
        float k24 = function4(x1 + dt / 2 * k11, x2 + dt / 2 * k12, x3 + dt / 2 * k13, x4 + dt / 2 * k14);

        float k31 = function1(x2 + dt / 2 * k22);
        float k32 = function2(x1 + dt / 2 * k21, x2 + dt / 2 * k22, x3 + dt / 2 * k23, x4 + dt / 2 * k24);
        float k33 = function3(x4 + dt / 2 * k24);
        float k34 = function4(x1 + dt / 2 * k21, x2 + dt / 2 * k22, x3 + dt / 2 * k23, x4 + dt / 2 * k24);

        float k41 = function1(x2 + dt * k32);
        float k42 = function2(x1 + dt * k31, x2 + dt * k32, x3 + dt * k33, x4 + dt * k34);
        float k43 = function3(x4 + dt * k34);
        float k44 = function4(x1 + dt * k31, x2 + dt * k32, x3 + dt * k33, x4 + dt * k34);

        x1 = x1 + dt / 6.0 * (k11 + 2 * k21 + 2 * k31 + k41);
        x2 = x2 + dt / 6.0 * (k12 + 2 * k22 + 2 * k32 + k42);
        x3 = x3 + dt / 6.0 * (k13 + 2 * k23 + 2 * k33 + k43);
        x4 = x4 + dt / 6.0 * (k14 + 2 * k24 + 2 * k34 + k44);

        diffEq1.push_back(x1);
        diffEq2.push_back(x2);
        diffEq3.push_back(x3);
        diffEq4.push_back(x4);
        time.push_back(t);
        torque.push_back(controlTrq(x1, x2, x3, x4));
    }

    return std::make_tuple(diffEq1, diffEq2, diffEq3, diffEq4, time, torque);
}

//---------------------------------------------------------------------------------------------------------

void plot2D(std::tuple<std::vector<float>, std::vector<float>> data1)
{

    std::vector<float> xX1 = std::get<0>(data1);
    std::vector<float> yY1 = std::get<1>(data1);

    plt::plot(xX1, yY1);
    plt::xlabel("t[s]");
    plt::ylabel("[rad]");
    plt::show();
}

//---------------------------------------------------------------

void plot2D2D(std::tuple<std::vector<float>, std::vector<float>> data1, std::tuple<std::vector<float>, std::vector<float>> data2)
{

    std::vector<float> xX1 = std::get<0>(data1);
    std::vector<float> yY1 = std::get<1>(data1);

    std::vector<float> xX2 = std::get<0>(data2);
    std::vector<float> yY2 = std::get<1>(data2);

    plt::plot(xX1, yY1);
    plt::plot(xX2, yY2);
    plt::xlabel("t[s]");
    plt::ylabel("[rad]");
    plt::show();
}

//---------------------------------------------------------------
int main()
{

    std::tuple<std::vector<float>, std::vector<float>, std::vector<float>, std::vector<float>, std::vector<float>, std::vector<float>> dyn = methodRuneKuttaSegway();

    std::tuple<std::vector<float>, std::vector<float>> theta = std::make_tuple(std::get<4>(dyn), std::get<0>(dyn));
    std::tuple<std::vector<float>, std::vector<float>> theta_dot = std::make_tuple(std::get<4>(dyn), std::get<1>(dyn));
    std::tuple<std::vector<float>, std::vector<float>> phi = std::make_tuple(std::get<4>(dyn), std::get<2>(dyn));
    std::tuple<std::vector<float>, std::vector<float>> phi_dot = std::make_tuple(std::get<4>(dyn), std::get<3>(dyn));
    std::tuple<std::vector<float>, std::vector<float>> torque = std::make_tuple(std::get<4>(dyn), std::get<5>(dyn));

    plot2D2D(theta, phi);
    plot2D2D(theta_dot, phi_dot);
    // plot2D(torque);
}
